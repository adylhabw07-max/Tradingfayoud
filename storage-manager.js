/**
 * مدير التخزين المحلي - Local Storage Manager
 * يدير التخزين المؤقت والنسخ الاحتياطي للبيانات في المتصفح
 */

class StorageManager {
    constructor() {
        // إعدادات التخزين
        this.config = {
            // مفاتيح التخزين
            keys: {
                marketData: 'trading_market_data',
                signals: 'trading_signals',
                analysis: 'trading_analysis',
                settings: 'trading_settings',
                apiKeys: 'trading_api_keys',
                cache: 'trading_cache'
            },
            
            // مدة صلاحية البيانات (بالميلي ثانية)
            expirationTimes: {
                marketData: 300000,    // 5 دقائق
                signals: 1800000,      // 30 دقيقة
                analysis: 600000,      // 10 دقائق
                cache: 60000,          // 1 دقيقة
                settings: 86400000,    // 24 ساعة
                apiKeys: 86400000      // 24 ساعة
            },
            
            // الحد الأقصى لحجم البيانات المخزنة (بالبايت)
            maxStorageSize: 10 * 1024 * 1024, // 10 MB
            
            // عدد النسخ الاحتياطية المحفوظة
            maxBackups: 5,
            
            // تفعيل الضغط
            compressionEnabled: true,
            
            // تفعيل التشفير البسيط
            encryptionEnabled: false
        };
        
        // إحصائيات التخزين
        this.stats = {
            totalWrites: 0,
            totalReads: 0,
            cacheHits: 0,
            cacheMisses: 0,
            storageUsed: 0,
            lastCleanup: null
        };
        
        // التحقق من دعم التخزين المحلي
        this.isLocalStorageSupported = this.checkLocalStorageSupport();
        this.isIndexedDBSupported = this.checkIndexedDBSupport();
        
        // تهيئة IndexedDB إذا كان مدعوماً
        if (this.isIndexedDBSupported) {
            this.initIndexedDB();
        }
        
        console.log('تم تهيئة مدير التخزين المحلي');\n        console.log(`دعم localStorage: ${this.isLocalStorageSupported}`);\n        console.log(`دعم IndexedDB: ${this.isIndexedDBSupported}`);\n    }\n    \n    /**\n     * التحقق من دعم localStorage\n     * @returns {boolean} دعم localStorage\n     */\n    checkLocalStorageSupport() {\n        try {\n            const test = 'test';\n            localStorage.setItem(test, test);\n            localStorage.removeItem(test);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    \n    /**\n     * التحقق من دعم IndexedDB\n     * @returns {boolean} دعم IndexedDB\n     */\n    checkIndexedDBSupport() {\n        return 'indexedDB' in window;\n    }\n    \n    /**\n     * تهيئة IndexedDB\n     */\n    async initIndexedDB() {\n        return new Promise((resolve, reject) => {\n            const request = indexedDB.open('TradingAppDB', 1);\n            \n            request.onerror = () => {\n                console.warn('فشل في تهيئة IndexedDB:', request.error);\n                reject(request.error);\n            };\n            \n            request.onsuccess = () => {\n                this.db = request.result;\n                console.log('تم تهيئة IndexedDB بنجاح');\n                resolve(this.db);\n            };\n            \n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                \n                // إنشاء مخازن البيانات\n                if (!db.objectStoreNames.contains('marketData')) {\n                    db.createObjectStore('marketData', { keyPath: 'id' });\n                }\n                \n                if (!db.objectStoreNames.contains('signals')) {\n                    db.createObjectStore('signals', { keyPath: 'id' });\n                }\n                \n                if (!db.objectStoreNames.contains('analysis')) {\n                    db.createObjectStore('analysis', { keyPath: 'id' });\n                }\n                \n                if (!db.objectStoreNames.contains('cache')) {\n                    db.createObjectStore('cache', { keyPath: 'key' });\n                }\n            };\n        });\n    }\n    \n    /**\n     * حفظ البيانات\n     * @param {string} key - مفتاح البيانات\n     * @param {*} data - البيانات المراد حفظها\n     * @param {Object} options - خيارات الحفظ\n     * @returns {Promise<boolean>} نجح الحفظ\n     */\n    async save(key, data, options = {}) {\n        try {\n            const saveOptions = {\n                useIndexedDB: false,\n                compress: this.config.compressionEnabled,\n                encrypt: this.config.encryptionEnabled,\n                expiration: this.config.expirationTimes[key] || 300000,\n                ...options\n            };\n            \n            // إعداد البيانات للحفظ\n            const saveData = {\n                data: data,\n                timestamp: Date.now(),\n                expiration: Date.now() + saveOptions.expiration,\n                compressed: false,\n                encrypted: false\n            };\n            \n            // ضغط البيانات إذا كان مفعلاً\n            if (saveOptions.compress) {\n                saveData.data = this.compressData(saveData.data);\n                saveData.compressed = true;\n            }\n            \n            // تشفير البيانات إذا كان مفعلاً\n            if (saveOptions.encrypt) {\n                saveData.data = this.encryptData(saveData.data);\n                saveData.encrypted = true;\n            }\n            \n            // اختيار طريقة التخزين\n            let success = false;\n            \n            if (saveOptions.useIndexedDB && this.isIndexedDBSupported && this.db) {\n                success = await this.saveToIndexedDB(key, saveData);\n            } else if (this.isLocalStorageSupported) {\n                success = this.saveToLocalStorage(key, saveData);\n            }\n            \n            if (success) {\n                this.stats.totalWrites++;\n                this.updateStorageStats();\n            }\n            \n            return success;\n            \n        } catch (error) {\n            console.error(`خطأ في حفظ البيانات للمفتاح ${key}:`, error);\n            return false;\n        }\n    }\n    \n    /**\n     * تحميل البيانات\n     * @param {string} key - مفتاح البيانات\n     * @param {Object} options - خيارات التحميل\n     * @returns {Promise<*>} البيانات المحملة أو null\n     */\n    async load(key, options = {}) {\n        try {\n            const loadOptions = {\n                useIndexedDB: false,\n                checkExpiration: true,\n                ...options\n            };\n            \n            let saveData = null;\n            \n            // اختيار طريقة التحميل\n            if (loadOptions.useIndexedDB && this.isIndexedDBSupported && this.db) {\n                saveData = await this.loadFromIndexedDB(key);\n            } else if (this.isLocalStorageSupported) {\n                saveData = this.loadFromLocalStorage(key);\n            }\n            \n            if (!saveData) {\n                this.stats.cacheMisses++;\n                return null;\n            }\n            \n            // التحقق من انتهاء الصلاحية\n            if (loadOptions.checkExpiration && Date.now() > saveData.expiration) {\n                console.log(`انتهت صلاحية البيانات للمفتاح: ${key}`);\n                await this.remove(key, { useIndexedDB: loadOptions.useIndexedDB });\n                this.stats.cacheMisses++;\n                return null;\n            }\n            \n            let data = saveData.data;\n            \n            // فك التشفير إذا كان مشفراً\n            if (saveData.encrypted) {\n                data = this.decryptData(data);\n            }\n            \n            // فك الضغط إذا كان مضغوطاً\n            if (saveData.compressed) {\n                data = this.decompressData(data);\n            }\n            \n            this.stats.totalReads++;\n            this.stats.cacheHits++;\n            \n            return data;\n            \n        } catch (error) {\n            console.error(`خطأ في تحميل البيانات للمفتاح ${key}:`, error);\n            this.stats.cacheMisses++;\n            return null;\n        }\n    }\n    \n    /**\n     * حذف البيانات\n     * @param {string} key - مفتاح البيانات\n     * @param {Object} options - خيارات الحذف\n     * @returns {Promise<boolean>} نجح الحذف\n     */\n    async remove(key, options = {}) {\n        try {\n            const removeOptions = {\n                useIndexedDB: false,\n                ...options\n            };\n            \n            let success = false;\n            \n            if (removeOptions.useIndexedDB && this.isIndexedDBSupported && this.db) {\n                success = await this.removeFromIndexedDB(key);\n            } else if (this.isLocalStorageSupported) {\n                success = this.removeFromLocalStorage(key);\n            }\n            \n            if (success) {\n                this.updateStorageStats();\n            }\n            \n            return success;\n            \n        } catch (error) {\n            console.error(`خطأ في حذف البيانات للمفتاح ${key}:`, error);\n            return false;\n        }\n    }\n    \n    /**\n     * حفظ البيانات في localStorage\n     * @param {string} key - المفتاح\n     * @param {Object} data - البيانات\n     * @returns {boolean} نجح الحفظ\n     */\n    saveToLocalStorage(key, data) {\n        try {\n            const serialized = JSON.stringify(data);\n            localStorage.setItem(key, serialized);\n            return true;\n        } catch (error) {\n            console.error('خطأ في حفظ البيانات في localStorage:', error);\n            return false;\n        }\n    }\n    \n    /**\n     * تحميل البيانات من localStorage\n     * @param {string} key - المفتاح\n     * @returns {Object|null} البيانات\n     */\n    loadFromLocalStorage(key) {\n        try {\n            const serialized = localStorage.getItem(key);\n            if (!serialized) return null;\n            return JSON.parse(serialized);\n        } catch (error) {\n            console.error('خطأ في تحميل البيانات من localStorage:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * حذف البيانات من localStorage\n     * @param {string} key - المفتاح\n     * @returns {boolean} نجح الحذف\n     */\n    removeFromLocalStorage(key) {\n        try {\n            localStorage.removeItem(key);\n            return true;\n        } catch (error) {\n            console.error('خطأ في حذف البيانات من localStorage:', error);\n            return false;\n        }\n    }\n    \n    /**\n     * حفظ البيانات في IndexedDB\n     * @param {string} key - المفتاح\n     * @param {Object} data - البيانات\n     * @returns {Promise<boolean>} نجح الحفظ\n     */\n    async saveToIndexedDB(key, data) {\n        return new Promise((resolve) => {\n            try {\n                const transaction = this.db.transaction(['cache'], 'readwrite');\n                const store = transaction.objectStore('cache');\n                \n                const request = store.put({ key: key, ...data });\n                \n                request.onsuccess = () => resolve(true);\n                request.onerror = () => {\n                    console.error('خطأ في حفظ البيانات في IndexedDB:', request.error);\n                    resolve(false);\n                };\n            } catch (error) {\n                console.error('خطأ في حفظ البيانات في IndexedDB:', error);\n                resolve(false);\n            }\n        });\n    }\n    \n    /**\n     * تحميل البيانات من IndexedDB\n     * @param {string} key - المفتاح\n     * @returns {Promise<Object|null>} البيانات\n     */\n    async loadFromIndexedDB(key) {\n        return new Promise((resolve) => {\n            try {\n                const transaction = this.db.transaction(['cache'], 'readonly');\n                const store = transaction.objectStore('cache');\n                \n                const request = store.get(key);\n                \n                request.onsuccess = () => {\n                    const result = request.result;\n                    if (result) {\n                        delete result.key; // إزالة المفتاح من البيانات\n                        resolve(result);\n                    } else {\n                        resolve(null);\n                    }\n                };\n                \n                request.onerror = () => {\n                    console.error('خطأ في تحميل البيانات من IndexedDB:', request.error);\n                    resolve(null);\n                };\n            } catch (error) {\n                console.error('خطأ في تحميل البيانات من IndexedDB:', error);\n                resolve(null);\n            }\n        });\n    }\n    \n    /**\n     * حذف البيانات من IndexedDB\n     * @param {string} key - المفتاح\n     * @returns {Promise<boolean>} نجح الحذف\n     */\n    async removeFromIndexedDB(key) {\n        return new Promise((resolve) => {\n            try {\n                const transaction = this.db.transaction(['cache'], 'readwrite');\n                const store = transaction.objectStore('cache');\n                \n                const request = store.delete(key);\n                \n                request.onsuccess = () => resolve(true);\n                request.onerror = () => {\n                    console.error('خطأ في حذف البيانات من IndexedDB:', request.error);\n                    resolve(false);\n                };\n            } catch (error) {\n                console.error('خطأ في حذف البيانات من IndexedDB:', error);\n                resolve(false);\n            }\n        });\n    }\n    \n    /**\n     * ضغط البيانات (تنفيذ بسيط)\n     * @param {*} data - البيانات\n     * @returns {string} البيانات المضغوطة\n     */\n    compressData(data) {\n        try {\n            // تنفيذ بسيط للضغط باستخدام JSON.stringify مع إزالة المسافات\n            const jsonString = JSON.stringify(data);\n            \n            // ضغط بسيط عن طريق إزالة المسافات والأحرف المكررة\n            let compressed = jsonString\n                .replace(/\\s+/g, ' ')  // استبدال المسافات المتعددة بمسافة واحدة\n                .replace(/: /g, ':')   // إزالة المسافة بعد النقطتين\n                .replace(/, /g, ',');  // إزالة المسافة بعد الفاصلة\n            \n            return compressed;\n        } catch (error) {\n            console.warn('فشل في ضغط البيانات:', error);\n            return JSON.stringify(data);\n        }\n    }\n    \n    /**\n     * فك ضغط البيانات\n     * @param {string} compressedData - البيانات المضغوطة\n     * @returns {*} البيانات الأصلية\n     */\n    decompressData(compressedData) {\n        try {\n            return JSON.parse(compressedData);\n        } catch (error) {\n            console.error('فشل في فك ضغط البيانات:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * تشفير البيانات (تنفيذ بسيط)\n     * @param {*} data - البيانات\n     * @returns {string} البيانات المشفرة\n     */\n    encryptData(data) {\n        try {\n            // تشفير بسيط باستخدام Base64 (ليس آمناً للبيانات الحساسة)\n            const jsonString = JSON.stringify(data);\n            return btoa(jsonString);\n        } catch (error) {\n            console.warn('فشل في تشفير البيانات:', error);\n            return JSON.stringify(data);\n        }\n    }\n    \n    /**\n     * فك تشفير البيانات\n     * @param {string} encryptedData - البيانات المشفرة\n     * @returns {*} البيانات الأصلية\n     */\n    decryptData(encryptedData) {\n        try {\n            const jsonString = atob(encryptedData);\n            return JSON.parse(jsonString);\n        } catch (error) {\n            console.error('فشل في فك تشفير البيانات:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * إنشاء نسخة احتياطية\n     * @param {string} name - اسم النسخة الاحتياطية\n     * @returns {Promise<boolean>} نجح الإنشاء\n     */\n    async createBackup(name) {\n        try {\n            const backup = {\n                name: name,\n                timestamp: Date.now(),\n                data: {}\n            };\n            \n            // جمع جميع البيانات المخزنة\n            for (const [keyName, storageKey] of Object.entries(this.config.keys)) {\n                const data = await this.load(storageKey, { checkExpiration: false });\n                if (data) {\n                    backup.data[keyName] = data;\n                }\n            }\n            \n            // حفظ النسخة الاحتياطية\n            const backupKey = `backup_${name}_${backup.timestamp}`;\n            const success = await this.save(backupKey, backup, { expiration: 86400000 * 7 }); // أسبوع\n            \n            if (success) {\n                console.log(`تم إنشاء النسخة الاحتياطية: ${name}`);\n                await this.cleanupOldBackups();\n            }\n            \n            return success;\n            \n        } catch (error) {\n            console.error('خطأ في إنشاء النسخة الاحتياطية:', error);\n            return false;\n        }\n    }\n    \n    /**\n     * استعادة نسخة احتياطية\n     * @param {string} backupKey - مفتاح النسخة الاحتياطية\n     * @returns {Promise<boolean>} نجحت الاستعادة\n     */\n    async restoreBackup(backupKey) {\n        try {\n            const backup = await this.load(backupKey, { checkExpiration: false });\n            \n            if (!backup || !backup.data) {\n                console.error('النسخة الاحتياطية غير موجودة أو تالفة');\n                return false;\n            }\n            \n            // استعادة البيانات\n            for (const [keyName, data] of Object.entries(backup.data)) {\n                const storageKey = this.config.keys[keyName];\n                if (storageKey) {\n                    await this.save(storageKey, data);\n                }\n            }\n            \n            console.log(`تم استعادة النسخة الاحتياطية: ${backup.name}`);\n            return true;\n            \n        } catch (error) {\n            console.error('خطأ في استعادة النسخة الاحتياطية:', error);\n            return false;\n        }\n    }\n    \n    /**\n     * تنظيف النسخ الاحتياطية القديمة\n     */\n    async cleanupOldBackups() {\n        try {\n            if (!this.isLocalStorageSupported) return;\n            \n            const backupKeys = [];\n            \n            // العثور على جميع مفاتيح النسخ الاحتياطية\n            for (let i = 0; i < localStorage.length; i++) {\n                const key = localStorage.key(i);\n                if (key && key.startsWith('backup_')) {\n                    backupKeys.push(key);\n                }\n            }\n            \n            // ترتيب النسخ حسب التاريخ (الأحدث أولاً)\n            backupKeys.sort((a, b) => {\n                const timestampA = parseInt(a.split('_').pop());\n                const timestampB = parseInt(b.split('_').pop());\n                return timestampB - timestampA;\n            });\n            \n            // حذف النسخ الزائدة\n            if (backupKeys.length > this.config.maxBackups) {\n                const toDelete = backupKeys.slice(this.config.maxBackups);\n                for (const key of toDelete) {\n                    await this.remove(key);\n                    console.log(`تم حذف النسخة الاحتياطية القديمة: ${key}`);\n                }\n            }\n            \n        } catch (error) {\n            console.error('خطأ في تنظيف النسخ الاحتياطية:', error);\n        }\n    }\n    \n    /**\n     * تنظيف البيانات المنتهية الصلاحية\n     */\n    async cleanup() {\n        try {\n            console.log('بدء تنظيف البيانات المنتهية الصلاحية...');\n            \n            let cleanedCount = 0;\n            \n            if (this.isLocalStorageSupported) {\n                const keysToCheck = [];\n                \n                // جمع جميع المفاتيح\n                for (let i = 0; i < localStorage.length; i++) {\n                    const key = localStorage.key(i);\n                    if (key) keysToCheck.push(key);\n                }\n                \n                // فحص كل مفتاح\n                for (const key of keysToCheck) {\n                    try {\n                        const data = this.loadFromLocalStorage(key);\n                        if (data && data.expiration && Date.now() > data.expiration) {\n                            this.removeFromLocalStorage(key);\n                            cleanedCount++;\n                        }\n                    } catch (error) {\n                        // تجاهل الأخطاء في البيانات التالفة\n                        continue;\n                    }\n                }\n            }\n            \n            this.stats.lastCleanup = Date.now();\n            this.updateStorageStats();\n            \n            console.log(`تم تنظيف ${cleanedCount} عنصر منتهي الصلاحية`);\n            \n        } catch (error) {\n            console.error('خطأ في تنظيف البيانات:', error);\n        }\n    }\n    \n    /**\n     * تحديث إحصائيات التخزين\n     */\n    updateStorageStats() {\n        try {\n            if (!this.isLocalStorageSupported) return;\n            \n            let totalSize = 0;\n            \n            for (let i = 0; i < localStorage.length; i++) {\n                const key = localStorage.key(i);\n                if (key) {\n                    const value = localStorage.getItem(key);\n                    if (value) {\n                        totalSize += key.length + value.length;\n                    }\n                }\n            }\n            \n            this.stats.storageUsed = totalSize;\n            \n        } catch (error) {\n            console.error('خطأ في تحديث إحصائيات التخزين:', error);\n        }\n    }\n    \n    /**\n     * الحصول على إحصائيات التخزين\n     * @returns {Object} الإحصائيات\n     */\n    getStats() {\n        this.updateStorageStats();\n        \n        return {\n            ...this.stats,\n            storageUsedMB: (this.stats.storageUsed / (1024 * 1024)).toFixed(2),\n            maxStorageMB: (this.config.maxStorageSize / (1024 * 1024)).toFixed(2),\n            storageUsagePercent: ((this.stats.storageUsed / this.config.maxStorageSize) * 100).toFixed(2),\n            cacheHitRate: this.stats.totalReads > 0 ? \n                ((this.stats.cacheHits / this.stats.totalReads) * 100).toFixed(2) + '%' : '0%',\n            isLocalStorageSupported: this.isLocalStorageSupported,\n            isIndexedDBSupported: this.isIndexedDBSupported\n        };\n    }\n    \n    /**\n     * مسح جميع البيانات\n     * @param {boolean} includeBackups - مسح النسخ الاحتياطية أيضاً\n     */\n    async clearAll(includeBackups = false) {\n        try {\n            console.log('مسح جميع البيانات المخزنة...');\n            \n            if (this.isLocalStorageSupported) {\n                const keysToDelete = [];\n                \n                for (let i = 0; i < localStorage.length; i++) {\n                    const key = localStorage.key(i);\n                    if (key) {\n                        // مسح البيانات العادية\n                        if (Object.values(this.config.keys).includes(key)) {\n                            keysToDelete.push(key);\n                        }\n                        \n                        // مسح النسخ الاحتياطية إذا كان مطلوباً\n                        if (includeBackups && key.startsWith('backup_')) {\n                            keysToDelete.push(key);\n                        }\n                    }\n                }\n                \n                keysToDelete.forEach(key => localStorage.removeItem(key));\n            }\n            \n            // مسح IndexedDB إذا كان متاحاً\n            if (this.isIndexedDBSupported && this.db) {\n                const transaction = this.db.transaction(['cache'], 'readwrite');\n                const store = transaction.objectStore('cache');\n                await store.clear();\n            }\n            \n            // إعادة تعيين الإحصائيات\n            this.stats = {\n                totalWrites: 0,\n                totalReads: 0,\n                cacheHits: 0,\n                cacheMisses: 0,\n                storageUsed: 0,\n                lastCleanup: Date.now()\n            };\n            \n            console.log('تم مسح جميع البيانات بنجاح');\n            \n        } catch (error) {\n            console.error('خطأ في مسح البيانات:', error);\n        }\n    }\n    \n    /**\n     * تصدير البيانات\n     * @returns {Object} البيانات المصدرة\n     */\n    async exportData() {\n        try {\n            const exportData = {\n                timestamp: Date.now(),\n                version: '1.0',\n                data: {}\n            };\n            \n            // تصدير جميع البيانات\n            for (const [keyName, storageKey] of Object.entries(this.config.keys)) {\n                const data = await this.load(storageKey, { checkExpiration: false });\n                if (data) {\n                    exportData.data[keyName] = data;\n                }\n            }\n            \n            return exportData;\n            \n        } catch (error) {\n            console.error('خطأ في تصدير البيانات:', error);\n            return null;\n        }\n    }\n    \n    /**\n     * استيراد البيانات\n     * @param {Object} importData - البيانات المستوردة\n     * @returns {Promise<boolean>} نجح الاستيراد\n     */\n    async importData(importData) {\n        try {\n            if (!importData || !importData.data) {\n                console.error('بيانات الاستيراد غير صحيحة');\n                return false;\n            }\n            \n            // استيراد البيانات\n            for (const [keyName, data] of Object.entries(importData.data)) {\n                const storageKey = this.config.keys[keyName];\n                if (storageKey) {\n                    await this.save(storageKey, data);\n                }\n            }\n            \n            console.log('تم استيراد البيانات بنجاح');\n            return true;\n            \n        } catch (error) {\n            console.error('خطأ في استيراد البيانات:', error);\n            return false;\n        }\n    }\n}\n\n// تصدير الكلاس للاستخدام\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = StorageManager;\n} else {\n    window.StorageManager = StorageManager;\n}

